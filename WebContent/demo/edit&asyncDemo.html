<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
 <HEAD>
  <TITLE> ZTREE DEMO </TITLE>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" href="demoStyle/demo.css" type="text/css">
  <link rel="stylesheet" href="zTreeStyle/zTreeStyle.css" type="text/css">
  <script type="text/javascript" src="jquery-1.4.2.js"></script>
  <script type="text/javascript" src="jquery-ztree-2.4.js"></script>
  <SCRIPT LANGUAGE="JavaScript">
  <!--
	var zTree1;
	var setting;

	setting = {
		editable: true,
		edit_renameBtn: setRenameBtn,
		async: true,
//		asyncUrl: "asyncData/node.jsp",
		asyncUrl: "asyncData/node.php",  
		asyncParam: ["name", "id"],
		callback: {
			beforeExpand: zTreeBeforeExpand,
			beforeDrop: zTreeBeforeDrop,
			beforeRemove: zTreeBeforeRemove,
			drop: zTreeOnDrop,
			expand: zTreeOnExpand,
			remove: zTreeOnRemove
		}
	};

	$(document).ready(function(){
		refreshTree();
	});

	function setRenameBtn(treeNode) {
		return false;
	}
	var srcParentNode = null;
	function zTreeBeforeDrop(treeId, treeNode, targetNode, moveType) {
		if (targetNode && !targetNode.isParent && $("#leafTrue").attr("checked") && moveType=="inner") {
			alert("叶子节点无法成为父节点!");
			return false;
		}
		srcParentNode = treeNode.parentNode;
		return true;
	}
	function zTreeOnDrop(event, treeId, treeNode, targetNode, moveType) {
		recoveryFolder();
	}
	function zTreeBeforeExpand(treeId, treeNode) {
		var r = true;
		if (treeNode.level >= 3 && (!treeNode.nodes || treeNode.nodes.length<1)) {
			r = false;
			alert(" Demo 不支持异步加载更深的子节点...");
		}
		return r;
	}
	function zTreeOnExpand(event, treeId, treeNode) {	
		if (!treeNode.nodes || treeNode.nodes.length<1) {
			zTree1.reAsyncChildNodes(treeNode, "refresh");
		}
	}
	function zTreeBeforeRemove(treeId, treeNode) {
		srcParentNode = treeNode.parentNode;
		return true;
	}
	function zTreeOnRemove(event, treeId, treeNode) {
		recoveryFolder();
	}

	function recoveryFolder() {
		if (srcParentNode && !srcParentNode.isParent && $("#parentTrue").attr("checked")) {
			srcParentNode.isParent = true;
			srcParentNode.open = false;
			zTree1.updateNode(srcParentNode);
		}
	}

	function refreshTree() {
		zTree1 = $("#treeDemo").zTree(setting);
	}

  //-->
  </SCRIPT>
 </HEAD>

<BODY>
<center class="headTitle">编辑演示<span> —— 编辑 与 异步加载 共存</span></center>
<TABLE border=0 width="700" class="tb1">
	<TR>
		<TD width=340px align=center valign=top>
		<div class="zTreeDemoBackground">
			<ul id="treeDemo" class="tree"></ul>
		</div>		
		</TD>
		<TD width=360px align=left valign=top>
		<div class="demoContent">
			<li class="title focus">
				<font color="red" style="font-size:12px;">此演示需要发布到 php 服务器下方能正常执行。<br/>
				使用 Tomcat 的朋友，请修改asyncUrl的值</font>
			</li>
			<li class="title focus">
				<button class="ico star" onfocus="this.blur();"></button>编辑规则切换
				<ul class="remark">——修改以下配置后，看看变化</ul>
				<ul>
					永远保持父节点isParent状态: <INPUT TYPE="radio" id="parentTrue" NAME="parentBtn" checked>true
					<INPUT TYPE="radio" id="parentFalse" NAME="parentBtn">false
				</ul>
				<ul>
					叶子节点无法成为父节点: <INPUT TYPE="radio" id="leafTrue" NAME="leafBtn" checked>true
					<INPUT TYPE="radio" id="leafTrue" NAME="leafBtn">false
				</ul>
			</li>
			<li class="title focus">
				<button class="ico books" onfocus="this.blur();"></button>编辑 与 异步加载 共存 说明
				<ul class="remark">
					<li>1、关键参数：isParent</li>
				</ul>
				<ul class="event">
					<li>A、渲染节点时，通过 isParent 来确定是否显示为父节点</li>
					<li>B、异步加载时，通过 isParent 以及是否存在子节点，来确定是否需要异步加载子节点</li>
					<li>C、编辑过程中，由于灵活的拖拽会导致 isParent 在子节点变化的时候而发生改变，从而导致与异步加载之间的冲突</li>
				</ul>
				<ul class="remark">
					<li>2、灵活的 reAsyncChildNodes 接口</li>
				</ul>
				<ul class="event">
					<li>A、从 v2.2 版本开始，zTree 提供了用户指定父节点进行异步加载的接口</li>
					<li>B、在 expand 事件回调函数，根据自己的规则利用这个接口可以很好的将 编辑状态 与 异步加载状态 结合起来</li>
				</ul>
				<ul class="remark">
					<li>3、父节点、叶子节点的状态</li>
				</ul>
				<ul class="event">
					<li>A、默认规则：任意节点只要 isParent=true 或 存在子节点，就是父节点；只要 isParent!=true 且 没有子节点 就是叶子节点</li>
					<li>B、默认规则：如果将父节点的子节点全部删除或移走，则该父节点就成为叶子节点（<font color="red">将上面第一个配置修改为：false</font>）</li>
					<li>C、默认规则：如果将某节点移动到叶子节点内，则该叶子节点就成为父节点（<font color="red">将上面第二个配置修改为：false</font>）</li>
					<li>D、这个 Demo 利用 beforeDrop、drop、beforeRemove、remove 这几个事件回调函数将默认规则进行了一定的调整，仅供参考</li>
				</ul>
			</li>
		</div>	
		</TD>
	</TR>
</TABLE>
 </BODY>
</HTML>
